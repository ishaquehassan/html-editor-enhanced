<html lang="en" ng-app="dhEditorApp">
<head>
    <meta charset="UTF-8"/>
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="description" content="Flutter Summernote HTML Editor"/>
    <meta name="author" content="tneotia"/>
    <title>Summernote Text Editor HTML</title>
    <script src="jquery.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link
            href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap"
            rel="stylesheet"
    />
    <!--summernote js and css-->
    <link href="summernote-lite.min.css" rel="stylesheet"/>
    <script src="summernote-lite.min.js"></script>
    <!--darkCSS-->
</head>
<body ng-controller="dhEditorController">
<div id="summernote-2"></div>
<!--headString-->
<!--summernoteScripts-->
<!--minor styling to improve editor design-->
<div id="dhEditorTextHighlights">
    <!--{{ editorHighlights }}-->

    <span id="counter"></span>
    <span ng-repeat="(index, highlight) in parsedEditorHighlights" ng-if="highlight.width != '1px'" style="
    position: absolute;
    left:{{highlight.left}};
    top:{{highlight.top}};
    width:{{highlight.width}}; color: transparent !important; border-bottom: 1px solid green; background-color: red; opacity: .3; {{highlight.css}}" data-idx="{{highlight.startIndex}} | {{highlight.endIndex}}" class="bg-primary absolute">{{highlight.text}}</span>
</div>
<style>
    * {
        font-family: 'Poppins', sans-serif !important;
    }

    body,
    html {
        overflow: hidden !important;
    }

    .note-editor.note-frame .note-editing-area .note-editable {
        padding-bottom: 30px !important;
    }

    .note-editor.note-frame .note-statusbar {
        display: none;
    }

    p {
        margin: 0;
    }

    *:not(h1) {
        font-size: 14px;
        line-height: 22px;
    }

    body {
        display: block;
        margin: 0px;
    }

    .note-editor.note-airframe,
    .note-editor.note-frame {
        border: 0px solid #a9a9a9;
        height: 100%;
    }

    .note-frame {
        border-radius: 0px;
    }

    h1,
    h1 * {
        font-size: 16px !important;
        line-height: 24px;
        margin: 0;
    }

    h1 {
        font-weight: 500 !important;
        font-weight: normal;
    }

</style>
<!--angular js-->
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js"></script>
<!--angular js-->
<script>
    Array.prototype.max = function() {
        return Math.max.apply(null, this);
    };


    angular.module('dhEditorApp', []).controller('dhEditorController', ($scope) => {
        window.dhNgEditorScope = $scope;
        $scope.editorHighlights = [];
        $scope.parsedEditorHighlights = [];
        $scope.$watch('editorHighlights', function() {
            $scope.reloadParsed();
        });
        $scope.reloadParsed = () => {
            $scope.parsedEditorHighlights = [];
            let numOfRetries = 0;
            while (true) {
                console.error(`=========================START ${++numOfRetries}=================================`)
                let existingHighlights = $scope.parsedEditorHighlights;
                let mewStartIndex = existingHighlights.length ? existingHighlights.map((h) => h.endIndex).max() : 0;
                let newHighlights = $scope.editorHighlights.map((line) => {
                    let pos = $scope.getTextPosition(line.text,mewStartIndex);
                    if(pos){
                        return pos.map((highlight) => ({...line, ...highlight}))
                    }else {
                        return []
                    }
                }).flat();
                if(!newHighlights.length){
                    break;
                }
                $scope.parsedEditorHighlights = [
                    ...$scope.parsedEditorHighlights,
                    ...newHighlights
                ];
                console.error(`=========================END ${numOfRetries}=================================`)
            }
            console.error($scope.parsedEditorHighlights)
        }

        window.jQuery("body").on('DOMSubtreeModified', '.note-editable', function(){
            setTimeout(() => {
               // alert(window.jQuery('.note-editable').html());
                $scope.highlightsFound = [];
                $scope.reloadParsed()
                $scope.$apply();
                //alert("a")
            },200);
        });

        $scope.onPhraseTap = () => {
            alert("Hello world")
        }

        $scope.createOverlay = (startNode, startIndex, endIndex, str) => {
            const containerRef = document.getElementById("dhEditorTextHighlights");

            if (!containerRef) return null;

            // Calculate the position and width of the overlay
            const range = document.createRange();
            range.setStart(startNode, startIndex);
            range.setEnd(startNode, endIndex);
            const rects = Array.from(range.getClientRects());
            const containerRect = containerRef.getBoundingClientRect();

            let wordMap = {}
            let words = str.split(" ");
            if(words.length > 1){
                let nextIndex = startIndex;
                words.forEach((word) => {
                    const range = document.createRange();
                    range.setStart(startNode, nextIndex+word.length-2);
                    range.setEnd(startNode, nextIndex+word.length-1);
                    let currentTop = range.getBoundingClientRect().top;
                    if (!wordMap[currentTop]){
                        wordMap[currentTop] = []
                    }
                    wordMap[currentTop].push(word);
                    nextIndex += ++word.length;
                });
            }

            return rects.map(rect => {
                return {
                    startIndex,
                    endIndex,
                    text: wordMap[rect.top] ?  wordMap[rect.top].join(" ") : str,
                    left: (rect.left - containerRect.left) + 'px',
                    top: (rect.top - containerRect.top) + 'px', // 2px border, adjust as needed
                    width: (rect.width || 1) + 'px', // Ensure a minimum width
                    height: (rect.height || 1) + 'px' // Ensure a minimum height
                }
            })
        }

        $scope.getTextPosition = (textToFind,startFrom) => {
            textToFind = `${textToFind}`
            console.error(textToFind,startFrom);

            const elements = document.querySelectorAll('.note-editable > *');
            let startIndex = -1;
            let elIndex = 0;

            for (let i = 0; i < elements.length; i++) {
                const elementText = elements[i].textContent;

                if (!elementText) continue;

                const index = elementText.indexOf(textToFind,startFrom);
                if (index !== -1) {
                    startIndex = index;
                    elIndex = i;
                    break;
                }
            }


            if (startIndex !== -1) {
                const endIndex = startIndex + textToFind.length;
                const child = elements[elIndex].firstChild ? elements[elIndex].firstChild : elements[elIndex];

                return $scope.createOverlay(child, startIndex, endIndex, textToFind);
            }

            return null;
        };

    });


    document.addEventListener("selectionchange", function () {
        if(window.dhNgEditorScope){
            let ngS = window.dhNgEditorScope;
            let currentRangeOffset = document.getSelection().getRangeAt(0).startOffset;
            let filtered = ngS.parsedEditorHighlights.filter((highlight) => highlight.startIndex <= currentRangeOffset && highlight.endIndex >= currentRangeOffset);
            if(filtered.length && filtered[0].onTap != null){
                filtered[0].onTap();
            }
            document.querySelector("#counter").textContent = `${currentRangeOffset}`;
        }
    })
</script>
</body>
</html>
